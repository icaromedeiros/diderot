\documentclass{report}

\setcounter{tocdepth}{3} % put subsubsections in TOC
\usepackage{graphicx}
\usepackage{url}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage[toc,page]{appendix}
\linespread{1.5}

\begin{document}

\title{Marvin - A Test Driven Development Tool for developing RDF/OWL ontologies}
\author{
Ícaro Medeiros\\
Matrícula 1212403
\\ \\ \\ \\ \\ \\ \\ \\
Pontifical Catholic University of Rio de Janeiro \\
Doctorate in Computer Science \\
INF 2102 - Programming Final Project (Projeto final de Programação) \\
Coordinator: Prof. Arndt Von Staa \\
Advisor: Prof. Daniel Schwabe
}

\maketitle
\tableofcontents

\chapter{Introduction}

Test Driven Development (TDD) techniques have been successfully used in
software engineering \cite{beck03}, providing an iterative, agile and incremental way of developing
code. In this approach, programmers start by writing tests for their code, then programming the code
so the tests do not fail. Then code can be enhanced and checked against tests again, completing a desirable
test-write-refactor cycle.

TDD is a safe methodology to develop programs, where we can be sure that changes do not
introduce bugs or unexpected behavior by running our automated tests for our code. Moreover,
by doing tests first, we can check our architecture decisions simply by being clients of our own code
in our tests. Finally (?), the tests can be seen as a documentation about the code.

Almost all modern programming languages have unit test frameworks that enable to run
automated tests for your code and engage into a TDD process for software, such as the xUnit
framework \cite{beck03} and its implementations (JUnit, Python unit testing framework, etc).

In a TDD approach you can start with simple software units, in a bottom-up way,
rather than over modeling all your system in advance, the so called Big Design Up Front (BDUF).
This leads to code that can rapidly be released, in short cycles, enabling early releases of
shipable software for the clients to validate and provide feedback, a premise in Agile
Software Process Methodologies \cite{beck01, beck04, martin03}.

Ontology engineering could benefit from a TDD process like this, using small iterations
to ensure a good quality ontology, consistent, well tested and ready for evolution.

\section{Test Driven Development for Ontologies}

During the ontology development authors might not be aware what kinds of inferences their ontologies are
providing, for example, if a new rule introduced unexpected inference. Checking the ontology for
self-consistency is also a demanding task.

As stated in \cite{vrandevcic06}, the idea of design by contract, well known in Software Engineering can
be used to Ontology Engineering as follows: we could declare what statements should and
should not derive from an ontology being developed. Thus we can be sure if expected inferences are
derived and be aware of unexpected inferred conclusions.

Moreover, competency questions, as defined by some methodologies for Ontology Engineering like Methontology \cite{lopez99},
describe what kind of knowledge the resulting ontology is supposed to answer. These questions can always be formalized in
a query language (like SPARQL). By formalizing the queries and the expected answers, a system can automatically checks if
the ontology meets the requirements stated with the competency questions.

% TODO example

To answer these needs in this report is proposed a novel Test Driven Development tool for building RDF/OWL ontologies, called
Marvin. This report is organized as follows: the Chapter \ref{system} describes the requirements, use cases, architecture and
how Marvin was built. In Chapter \ref{manual} it is described how to use Marvin in all its use cases, including installation.
Finally, in Chapter \ref{conclusion} we present concluding remarks and future goals for the project.

\chapter{System Description}
\label{system}

This chapter will describe the goals defined for Marvin, a tool for Test Driven Development for building RDF/OWL ontologies
and how the system was built, including use cases, architecture and the engineering process.

\section{Goals}
\label{goals}

The main goals of Marvin is to provide a simple interface to test small portions of ontologies regarding:

\begin{itemize}
    \item Expected inferences. The system must check if expected inferences are satisfied by the ontology
        given as input.
    \item Check for lack of unexpected inferences. The system must guarantee that no unexpected inferences are
        derived from the target ontology.
    \item Self consistency check. The system must check if rules stated in the ontology do not
        contradict each other thus leading to guaranteed ontology consistency.
    \item Answering competency questions. The system must check if answers to competency questions are
        the same as users expect, given the target ontologies and the knowledge base which uses the ontology.
\end{itemize}

\section{Requirements}
\label{requirements}

The requirements of Marvin follows:
\begin{itemize}
    \item To provide facilities for testing ontologies regarding the goals mentioned in Section \ref{goals}: cheking
        expected and lack of unexpected inferences, self consistency and proper competency questions answering.
    \item The input to the system should be made in many formats possible, such as Turtle format for RDF serialization,
        as a simple way of writting RDF. The input might be a string representing RDF in Turtle format, a file or a
        URI that contains a RDF ontology. Also, it is desirable to provide a SPARQL interface to writting competency questions.
    \item To provide a simple Domain Specific Language for writting tests for ontologies. The API of the tool must be simple
        to use and extend to cover different test scenarios.
    \item To be written in Python. As the main language used in Globo.com having a tool written in Python is desirable.
        Moreover, the possibility to reuse tools such as RDFlib (for dealing with RDF data), the inference library FuXi
        and the Python unit testing framework lead to the requirement of using Python.
        Finally, Python is a multi-plataform language so the tool is available for all platforms that Python supports.
\end{itemize}

\subsection{Use Cases}

The use cases follow strictly the goals stated in Section \ref{goals}. A diagram summarizing the use cases is seen
in Figure \ref{figUseCase}.

\begin{figure}[!hbt]
    \centering
    \label{figUseCase}
    \caption{Use case diagram for Marvin}
    \includegraphics[scale=0.5]{fig/use_case_diagram.png}
\end{figure}

Following, the use cases will be described as user stories \cite{beck04}.

\subsubsection{Check Expected Inference}

As a ontology developer, I want to check expected inferences in ontologies so that I can develop them
in a safe way and be assure that their evolution will not break rules or invalidate previously
functional inferences.

\subsubsection{Check for lack of Unexpected Inference}

As a ontology developer, I want to check for lack of unexpected inferences so that unwanted facts
derived from the ontology do no harm ontology consistency or its uses.

\subsubsection{Check Ontology Self Consistency}

As a ontology developer, I want to check ontology for self consistency so that inferences are able to
function properly.

\subsubsection{Check Answering to Competency Question}

As a ontology developer, I want to check expected answers for competency questions that are required
so that ontology can fulfill its goal. The question can be asked as a SPARQL query.

\section{Architecture}

Marvin architecture is summarized in Figure \ref{figArchitecture}.
The \texttt{case} module is the interface with our users (programmers).
Users must extend \texttt{MarvinTestCase} (main class in \texttt{case} module) in their test cases to use Marvin.
\texttt{MarvinTestCase}, in turn, extends \texttt{TestCase} (from \texttt{unittest}, the Python unit testing framework).
In Marvin's test cases, assertions (in the \texttt{assertion} module) are used to check, for example, that expected facts can be inferred from the input ontology.

Finally, assertions use the \texttt{rules} modules to trigger inferences in \texttt{FuXi}, a inference machine written in Python.
\texttt{Fuxi} uses rules that express RDF and OWL semantics to perform its inferences.

\texttt{RDFLib} and the \texttt{utils} package are used through all the code to perform utilitary functions such as parsing of ontologies written in Turtle format for RDF, checking if a \texttt{RDFLib graph} object contains a subset of triples of another object and so on.

\begin{figure}[!hbt]
    \centering
    \label{figArchitecture}
    \caption{Marvin architecture}
    \includegraphics[scale=0.33]{fig/architecture.png}
\end{figure}

\section{Engineering Process}

During the development of Marvin, the code (and this report) was hosted in Github
\footnote{Available at \url{http://github.com/icaromedeiros/marvin}}, a social coding tool that enables free software
sharing. The Semantic Web community and all users are welcome to contribute to the project and give feedback.

Within Github users can open issues, fork the project (create your own copy) and perform pull requests (patches to the
current code to be accepted by project maintainers) and so on in order to evolve the software. As today, many
important project are hosted on Github such as linux or Rails \footnote{Available at \url{http://github.com/torvalds/linux}
and \url{http://github.com/rails/rails}}.

Git version control was used in the software development, as it is the
default system used in Github and currently the most complete and popular version control system.

An example of the Github page for the project is seen in Figure \ref{figGithub}. In the inferior part of the figure we can see a build status badge (on green), stating that the build is passing. This is another agile development tecnhique used in Marvin: Continuos Integration \cite{beck04}. Every change pushed into Marvin's repository on github triggers automatically a run on the automated tests (fully explained in Section \ref{tests}), using the Travis CI\footnote{Available at \url{http://www.travis-ci.org/}} tool.

\begin{figure}[!hbt]
    \centering
    \label{figGithub}
    \caption{Github page of Marvin}
    \includegraphics[scale=0.4]{fig/github.png}
\end{figure}

As a software development methodology the Extreme Programming \cite{beck04} was chosen, with a focus on Test Driven
Development. It would be rather contradictory to build a TDD tool without using the methodology in its own development.
The tests are described next.

\subsection{Tests}
\label{tests}

In the Test Driven Development used to create Marvin different kinds of tests were used, namely:

\begin{itemize}
    \item Unit tests. Testing only small portions of code make the software APIs better, clean code safe for changes.
        It is done considering the code behind it, i.e. it is a white-box test.
    \item Functional tests. A quality assurance test that integrate multiple parts of the software and test broader
        functionalities, where nearly real data is often used.
        It is a black-box test as the internal program structure is mainly not considered.
    \item Acceptance tests. Test the software contract, i.e. if the requirements are fully satisfied. Mainly involve
        user interface tests, but as Marvin is mainly a developer tool, our acceptance tests are unit tests for ontologies
        using our tool and real examples of ontologies that test our requirements (Section \ref{requirements}).
\end{itemize}

\subsubsection{Unit Tests}

Currently, Marvin has XXX unit tests, covering 100\% of the code\footnote{Using coverage tool, available at \url{https://pypi.python.org/pypi/coverage}}.
Not only all the lines are tested, but all code branches (e.g. all conditional flows).

\subsubsection{Functional Tests}

Currenly, Marvin has XXX functional tests, covering XX\% of the code.
Functional tests cover broader functionalities such as asserting correct inference using different OWL capabilities.

\subsubsection{Acceptance Tests}

Acceptance tests cover all the requirements of the software to validate all the software use cases and cycles.
These tests are also used in the user manual \cite{manual} as they present real examples on how to use our tool.

\chapter{User Manual}
\label{manual}

Software documentation is rather confuse and incomplete.
A good documentation can make a real difference between low or high adopted software.
Therefore, Marvin documentation is extensive and well designed.

\section{Documentation}

The documentation is available online at \url{https://marvin.readthedocs.org}.
Using sphinx tool\footnote{Available at \url{http://sphinx-doc.org/}}, it was created documentation using
reStructuredText, a simple format to write documentation.
Sphinx compile the \texttt{.rst} files into HTML files that create a browsable and very usable documentation.

Besides the user documentation, API documentation was created automatically by using docstring code (i.e. comments on method headers) and
the autodoc Sphinx plugin.
This enables programmers to understand how the code works very fast.

% TODO Example with figure

\section{Installation}

To install Marvin, first users need to have Python 2.7 installed \footnote{Other Python versions were not tested. Instructions for installing Python in all platforms can be found in \url{www.python.org/download}}.
Pip tool is also need for installed all the required libraries \footnote{Instruction for installing pip can be found here \url{http://www.pip-installer.org/en/latest/installing.html}}.
It is recommended to use virtualenv tool \footnote{It is recommended to use virtualenv with virtualenvwrapper. Install these tool by using \texttt{pip install virtualenv} and \texttt{pip install virtualenvwrapper}.} to use different environments for Python projects.

After this, simply type \texttt{pip install marvin} and all its dependencies in the selected virtualenv, as seen in Figure \ref{figInstalling}.

% TODO figure

\subsection{Marvin dependencies}

Marvin reuses some libraries to work, namely:

\begin{itemize}
    \item \texttt{rdflib==2.4.2}. Library for parsing RDF files into Python objects, different types of RDF serialization and other facilities for dealing with RDF data.
    \item \texttt{FuXi==1.4.production}. Library for OWL inference on Python.
        It is needed to infer facts that can be derived from ontologies.
\end{itemize}
\section{Use Examples}

\chapter{Conclusion}
\label{conclusion}

\section{Future Work}

\begin{appendices}
\chapter{CD Content}

The CD ...

\end{appendices}

\bibliographystyle{plain}
\bibliography{refs}

\end{document}
